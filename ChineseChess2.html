<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chinese Chess (Xiangqi)</title>
<style>
  :root{--size:60px}
  body{font-family:Inter,Arial,Helvetica,sans-serif;background:#f3f4f6;margin:0;padding:24px;display:flex;justify-content:center}
  .container{display:flex;gap:20px;max-width:1100px}
  #left{background:#fdf7e3;padding:18px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.08)}
  canvas{background:#e7cfa3;border-radius:8px;display:block}
  #controls{margin-top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{padding:8px 12px;border-radius:6px;border:1px solid #bbb;background:white;cursor:pointer}
  select{padding:6px;border-radius:6px}
  #right{width:320px;background:white;padding:16px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.06)}
  h3{margin-top:0}
  #pieceInfoBox{font-size:14px;line-height:1.45}
  .turn{font-weight:700;margin-top:10px}
  #howToPlayModal{position:fixed;inset:0;background:rgba(0,0,0,0.45);display:none;align-items:center;justify-content:center}
  #howBox{background:white;padding:18px;border-radius:8px;max-width:720px;max-height:80vh;overflow:auto;position:relative}
  #howBox button{position:absolute;right:12px;top:12px}
  .note{font-size:13px;color:#444}
</style>
</head>
<body>
<div class="container">
  <div id="left">
    <h2>Chinese Chess (Xiangqi)</h2>
    <canvas id="board" width="600" height="660"></canvas>
    <div id="controls">
      <label for="playerColor">Choose your color:</label>
      <select id="playerColor"><option value="red">Red (top)</option><option value="black">Black (bottom)</option></select>
      <button id="startHuman">Play vs Human</button>
      <button id="startComputer">Play vs Computer</button>
      <button id="showHowToPlay">How to Play</button>
      <div class="turn" id="turnLabel">Turn: -</div>
    </div>
  </div>
  <aside id="right">
    <h3>Pieces & Movement</h3>
    <div id="pieceInfoBox"></div>
    <hr>
    <div class="note"><strong>Palace:</strong> 3×3 area at columns 3–5. Generals & Advisors must remain inside. <br>
    <strong>River:</strong> gap between rows 4 and 5. Elephants cannot cross. Soldiers gain sideways moves after crossing.</div>
    <div style="margin-top:10px;font-size:14px">
      <strong>Controls</strong>
      <div class="note">Click a piece of the side to move — legal destinations are highlighted. Selecting an empty square clears selection.</div>
    </div>
  </aside>
</div>

<div id="howToPlayModal">
  <div id="howBox">
    <button id="closeHowToPlay">Close</button>
    <h2>How to Play — Rules implemented</h2>
    <ul>
      <li><strong>General</strong>: 1 orthogonal inside palace. Flying general rule implemented.</li>
      <li><strong>Advisor</strong>: 1 diagonal inside palace.</li>
      <li><strong>Elephant</strong>: 2 diagonal, cannot cross river, blocked if midpoint occupied.</li>
      <li><strong>Horse</strong>: 1 orth then 1 diag (L). Blocked if orth adjacent square occupied.</li>
      <li><strong>Chariot</strong>: moves like rook any distance orthogonally until blocked.</li>
      <li><strong>Cannon</strong>: moves like chariot when not capturing. To capture it must jump exactly one piece (screen) and land on an opponent piece.</li>
      <li><strong>Soldier</strong>: 1 forward. After crossing river can also move 1 sideways. Cannot move backward.</li>
    </ul>
    <p>Additional features:</p>
    <ul>
      <li>Full legal-move generator for all pieces.</li>
      <li>Move highlighting and selected-square highlight.</li>
      <li>Turn enforcement, check/checkmate detection.</li>
      <li>Play vs computer (random legal moves) or two-player hot-seat.</li>
    </ul>
  </div>
</div>

<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const turnLabel = document.getElementById('turnLabel');
const startHuman = document.getElementById('startHuman');
const startComputer = document.getElementById('startComputer');
const playerColorEl = document.getElementById('playerColor');
const showHowToPlay = document.getElementById('showHowToPlay');
const howModal = document.getElementById('howToPlayModal');
const closeHowToPlay = document.getElementById('closeHowToPlay');
const pieceInfoBox = document.getElementById('pieceInfoBox');

const SIZE=60, OFFSET=60;
function inBounds(r,c){return r>=0&&r<10&&c>=0&&c<9}
function isUpper(s){return s && /[A-Z]/.test(s)}
function sameSide(a,b){ if(!a||!b) return false; return isUpper(a)===isUpper(b); }

const pieceInfo = {
  'K':'General — 1 orthogonal inside palace; cannot face opposing general directly without pieces between.',
  'A':'Advisor — 1 diagonal inside palace only.',
  'E':'Elephant — 2 diagonal; cannot cross river; blocked if midpoint occupied.',
  'H':'Horse — L-shape; blocked if the first orthogonal step (leg) occupied.',
  'R':'Chariot — rook-like (orthogonal unlimited).',
  'C':'Cannon — rook-like movement; capture by jumping over exactly one piece (screen).',
  'P':'Soldier — 1 forward; after crossing river may also move 1 sideways.'
};
pieceInfoBox.innerHTML = Object.entries(pieceInfo).map(([k,v])=>`<div><strong>${k}</strong>: ${v}</div>`).join('');

let board=[], turn='red', selected=null, vsComputer=false;

function resetBoard(){
  board = Array.from({length:10},()=>Array(9).fill(''));
  board[0] = ['R','H','E','A','K','A','E','H','R'];
  board[2][1]='C'; board[2][7]='C';
  board[3] = ['P','','P','','P','','P','','P'];
  board[9] = ['r','h','e','a','k','a','e','h','r'];
  board[7][1]='c'; board[7][7]='c';
  board[6] = ['p','','p','','p','','p','','p'];
}

function drawBoard(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.font='18px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
  
  const OFFSET = 60; // center offset for pieces
  const SIZE = 60;

  // vertical lines (skip river row)
  for(let c=0;c<9;c++){
    ctx.beginPath();
    // top part
    ctx.moveTo(OFFSET + c*SIZE, OFFSET);
    ctx.lineTo(OFFSET + c*SIZE, OFFSET + 4*SIZE);
    // bottom part
    ctx.moveTo(OFFSET + c*SIZE, OFFSET + 5*SIZE);
    ctx.lineTo(OFFSET + c*SIZE, OFFSET + 9*SIZE);
    ctx.strokeStyle='#333';
    ctx.stroke();
  }

  // horizontal lines (skip river row)
  for(let r=0;r<10;r++){
    if(r===4) continue; // skip river
    ctx.beginPath();
    ctx.moveTo(OFFSET, OFFSET + r*SIZE);
    ctx.lineTo(OFFSET + 8*SIZE, OFFSET + r*SIZE);
    ctx.strokeStyle='#333';
    ctx.stroke();
  }

  // palace diagonals
  function drawPalace(rowStart){
    ctx.beginPath();
    ctx.moveTo(OFFSET+3*SIZE, OFFSET+rowStart*SIZE);
    ctx.lineTo(OFFSET+5*SIZE, OFFSET+(rowStart+2)*SIZE);
    ctx.moveTo(OFFSET+5*SIZE, OFFSET+rowStart*SIZE);
    ctx.lineTo(OFFSET+3*SIZE, OFFSET+(rowStart+2)*SIZE);
    ctx.stroke();
  }
  drawPalace(0); // red palace
  drawPalace(7); // black palace

  // red-side line right before river
  ctx.beginPath();
  ctx.moveTo(OFFSET, OFFSET+4*SIZE);
  ctx.lineTo(OFFSET+8*SIZE, OFFSET+4*SIZE);
  ctx.stroke();

  // draw pieces
  for(let r=0;r<10;r++){
    for(let c=0;c<9;c++){
      const p = board[r][c];
      if(!p) continue;
      ctx.fillStyle = isUpper(p)?'#c0392b':'#2c3e50';
      ctx.beginPath(); ctx.arc(OFFSET+c*SIZE, OFFSET+r*SIZE,22,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='white'; ctx.fillText(p, OFFSET+c*SIZE, OFFSET+r*SIZE);
    }
  }

  // highlight selected + legal moves
  if(selected){
    const [sr,sc] = selected;
    ctx.strokeStyle = 'gold';
    ctx.lineWidth = 4;
    ctx.strokeRect(OFFSET+sc*SIZE-22, OFFSET+sr*SIZE-22,44,44);
    ctx.lineWidth = 1;

    const moves = generateMoves(sr,sc,true);
    for(const [r,c] of moves){
      ctx.fillStyle = 'rgba(0,200,0,0.35)';
      ctx.beginPath(); ctx.arc(OFFSET+c*SIZE, OFFSET+r*SIZE,12,0,Math.PI*2); ctx.fill();

      if(board[r][c]){
        ctx.strokeStyle='rgba(255,255,255,0.9)';
        ctx.beginPath(); ctx.arc(OFFSET+c*SIZE, OFFSET+r*SIZE,14,0,Math.PI*2); ctx.stroke();
      }
    }
  }
}


function cloneBoard(b){return b.map(r=>r.slice());}
function findGeneral(b, sideUpper){for(let r=0;r<10;r++)for(let c=0;c<9;c++){const p=b[r][c]; if(p && p.toUpperCase()==='K' && isUpper(p)===sideUpper) return [r,c];} return null;}
function isInCheck(b, side){const sideUpper=(side==='red'); const gen=findGeneral(b, sideUpper); if(!gen) return false; const [gr,gc]=gen; for(let r=0;r<10;r++)for(let c=0;c<9;c++){const p=b[r][c]; if(!p) continue; if(isUpper(p)===sideUpper) continue; const attacks=generateMovesForCheck(r,c,b); for(const [ar,ac] of attacks) if(ar===gr && ac===gc) return true;} return false; }

function generateMovesForCheck(sr, sc, tempBoard) {
  const piece = tempBoard[sr][sc];
  if (!piece) return [];
  const moves = [];
  const isRedPiece = isUpper(piece);
  const dir = isRedPiece ? 1 : -1; // forward direction
  const add = (r, c) => {
    if (!inBounds(r, c)) return;
    const target = tempBoard[r][c];
    if (!target || !sameSide(piece, target)) moves.push([r, c]);
  };
  const type = piece.toUpperCase();

  if (type === 'K') {
    const palaceRows = isRedPiece ? [0, 1, 2] : [7, 8, 9];
    [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dr, dc]) => {
      const nr = sr + dr, nc = sc + dc;
      if (palaceRows.includes(nr) && nc >= 3 && nc <= 5) add(nr, nc);
    });
    // flying general
    for (let rr = sr + dir; rr >= 0 && rr < 10; rr += dir) {
      const t = tempBoard[rr][sc];
      if (t) {
        if (t.toUpperCase() === 'K' && isUpper(t) !== isRedPiece) moves.push([rr, sc]);
        break;
      }
    }
  } else if (type === 'A') {
    const palaceRows = isRedPiece ? [0, 1, 2] : [7, 8, 9];
    [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => {
      const nr = sr + dr, nc = sc + dc;
      if (palaceRows.includes(nr) && nc >= 3 && nc <= 5) add(nr, nc);
    });
  } else if (type === 'E') {
    [[2, 2], [2, -2], [-2, 2], [-2, -2]].forEach(([dr, dc]) => {
      const nr = sr + dr, nc = sc + dc;
      const mr = sr + dr / 2, mc = sc + dc / 2;
      if (!inBounds(nr, nc)) return;
      if (isRedPiece && nr > 4) return;
      if (!isRedPiece && nr < 5) return;
      if (tempBoard[mr][mc]) return;
      add(nr, nc);
    });
  } else if (type === 'H') {
    const horse = [
      [1, 2, [0, 1]], [2, 1, [1, 0]], [2, -1, [1, 0]], [1, -2, [0, -1]],
      [-1, -2, [0, -1]], [-2, -1, [-1, 0]], [-2, 1, [-1, 0]], [-1, 2, [0, 1]]
    ];
    horse.forEach(([dr, dc, leg]) => {
      const lr = sr + leg[0], lc = sc + leg[1];
      if (inBounds(sr + dr, sc + dc) && !tempBoard[lr][lc]) add(sr + dr, sc + dc);
    });
  } else if (type === 'R' || type === 'C') {
    [[1, 0], [-1, 0], [0, 1], [0, -1]].forEach(([dr, dc]) => {
      let nr = sr + dr, nc = sc + dc;
      if (type === 'R') {
        while (inBounds(nr, nc)) {
          if (!tempBoard[nr][nc]) { add(nr, nc); nr += dr; nc += dc; }
          else { add(nr, nc); break; }
        }
      } else {
        while (inBounds(nr, nc) && !tempBoard[nr][nc]) { add(nr, nc); nr += dr; nc += dc; }
        if (inBounds(nr, nc)) {
          let sr2 = nr + dr, sc2 = nc + dc;
          while (inBounds(sr2, sc2)) {
            if (tempBoard[sr2][sc2]) { if (!sameSide(tempBoard[sr2][sc2], piece)) moves.push([sr2, sc2]); break; }
            sr2 += dr; sc2 += dc;
          }
        }
      }
    });
  } else if (type === 'P') {
    const fr = sr + dir;
    if (inBounds(fr, sc)) add(fr, sc); // forward move
    // sideways after crossing river
    const crossed = isRedPiece ? sr >= 5 : sr <= 4;
    if (crossed) {
      if (inBounds(sr, sc - 1)) add(sr, sc - 1); // left
      if (inBounds(sr, sc + 1)) add(sr, sc + 1); // right
    }
  }

  return moves;
}


function generateMoves(sr,sc,enforce=true){const piece=board[sr][sc]; if(!piece) return[]; const raw=generateMovesForCheck(sr,sc,board); if(!enforce) return raw; const legal=[]; for(const [r,c] of raw){ const copy=cloneBoard(board); copy[r][c]=copy[sr][sc]; copy[sr][sc]=''; const moverSide=isUpper(piece)?'red':'black'; if(!isInCheck(copy,moverSide)) legal.push([r,c]);} return legal;}

function makeMove(sr,sc,r,c){board[r][c]=board[sr][sc]; board[sr][sc]=''; turn=(turn==='red')?'black':'red'; updateTurnLabel();}

function updateTurnLabel(){turnLabel.innerText='Turn: '+turn.toUpperCase();}

function checkGameEnd(){const side=turn; const sideUpper=(side==='red'); let any=false; for(let r=0;r<10;r++)for(let c=0;c<9;c++){const p=board[r][c]; if(p && isUpper(p)===sideUpper){if(generateMoves(r,c,true).length>0) any=true;}} if(!any){if(isInCheck(board,side)){alert((side==='red'?'Red':'Black')+' is checkmated. '+(side==='red'?'Black':'Red')+' wins!');}else{alert('Stalemate — no legal moves.');} vsComputer=false; return true;} return false;}

function makeComputerMove(){const sideUpper=(turn==='red'); const all=[]; for(let r=0;r<10;r++)for(let c=0;c<9;c++){const p=board[r][c]; if(p && isUpper(p)===sideUpper){for(const mv of generateMoves(r,c,true)) all.push({from:[r,c],to:mv});}} if(all.length===0) return; const choice=all[Math.floor(Math.random()*all.length)]; makeMove(choice.from[0],choice.from[1],choice.to[0],choice.to[1]); drawBoard();}

function postMoveAI(){if(vsComputer && turn!==playerColorEl.value){setTimeout(()=>{makeComputerMove(); checkGameEnd();},250);}}

canvas.addEventListener('click',e=>{
  const rect=canvas.getBoundingClientRect();
  const x=e.clientX-rect.left, y=e.clientY-rect.top;
  const c=Math.round((x-OFFSET)/SIZE), r=Math.round((y-OFFSET)/SIZE);
  if(!inBounds(r,c)) return;
  const clicked=board[r][c];
  if(selected){const [sr,sc]=selected; const moves=generateMoves(sr,sc,true); if(moves.find(m=>m[0]===r && m[1]===c)){makeMove(sr,sc,r,c); selected=null; drawBoard(); setTimeout(()=>{postMoveAI(); checkGameEnd();},120); return;} else {if(clicked && isUpper(clicked)===(turn==='red')) selected=[r,c]; else selected=null; drawBoard(); return;}}
  if(clicked && isUpper(clicked)===(turn==='red')){selected=[r,c]; drawBoard();}
});

startHuman.addEventListener('click', ()=>{vsComputer=false; resetBoard(); turn='red'; selected=null; updateTurnLabel(); drawBoard();});
startComputer.addEventListener('click', ()=>{vsComputer=true; resetBoard(); turn='red'; selected=null; updateTurnLabel(); drawBoard(); if(playerColorEl.value==='black'){postMoveAI();}});
showHowToPlay.addEventListener('click',()=>{howModal.style.display='flex';});
closeHowToPlay.addEventListener('click',()=>{howModal.style.display='none';});

resetBoard(); drawBoard(); updateTurnLabel();
</script>
</body>
</html>

